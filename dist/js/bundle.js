(()=>{"use strict";var __webpack_modules__={577:()=>{eval("\n;// CONCATENATED MODULE: ./node_modules/typeit/dist/index.es.js\n// TypeIt by Alex MacArthur - https://typeitjs.com\nvar isArray = (thing) => Array.isArray(thing);\nvar asArray = (value) => {\n  return isArray(value) ? value : [value];\n};\nconst Queue = function(initialItems) {\n  const add = function(steps) {\n    _queue = _queue.concat(asArray(steps));\n    return this;\n  };\n  const set = function(index, item) {\n    _queue[index] = item;\n  };\n  const reset = function() {\n    _queue = _queue.map((item) => {\n      delete item.done;\n      return item;\n    });\n  };\n  const getItems = () => _queue.filter((i) => !i.done);\n  const markDone = (index) => {\n    _queue[index].done = true;\n  };\n  let _queue = [];\n  add(initialItems);\n  return {\n    add,\n    set,\n    reset,\n    getItems,\n    markDone\n  };\n};\nvar toArray = (val) => {\n  return Array.from(val);\n};\nvar createTextNode = (content) => {\n  return document.createTextNode(content);\n};\nconst expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nvar getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst START = \"START\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: true,\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nfunction walkElementNodes(element, shouldReverse = false) {\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      var _a;\n      return ((_a = node == null ? void 0 : node.classList) == null ? void 0 : _a.contains(CURSOR_CLASS)) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    nextNode.originalParent = nextNode.parentNode;\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nvar createElement = (el) => {\n  return document.createElement(el);\n};\nvar appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst isNumber = (value) => {\n  return Number.isInteger(value);\n};\nconst index_es_select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nvar isInput = (el) => {\n  return \"value\" in el;\n};\nconst getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter((c) => !(c.childNodes.length > 0));\n};\nconst calculateStepsToSelector = (selector, element, to = START) => {\n  let isMovingToLast = new RegExp(END, \"i\").test(to);\n  let selectedElement = selector ? index_es_select(selector, element) : element;\n  let selectedElementNodes = walkElementNodes(selectedElement, true);\n  let selectedElementFirstChild = selectedElementNodes[0];\n  let selectedElementLastChild = selectedElementNodes[selectedElementNodes.length - 1];\n  let isMovingToEndOfRootElement = isMovingToLast && !selector;\n  let childIndex = isMovingToEndOfRootElement ? 0 : getAllChars(element).findIndex((character) => {\n    return character.isSameNode(isMovingToLast ? selectedElementFirstChild : selectedElementLastChild);\n  });\n  if (isMovingToLast)\n    childIndex--;\n  return childIndex + 1;\n};\nvar calculateCursorSteps = ({\n  el,\n  move,\n  cursorPos,\n  to\n}) => {\n  if (isNumber(move)) {\n    return move * -1;\n  }\n  let childIndex = calculateStepsToSelector(move, el, to);\n  return childIndex - cursorPos;\n};\nvar calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nvar randomInRange = (value, range2) => {\n  return Math.abs(Math.random() * (value + range2 - (value - range2)) + (value - range2));\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nvar destroyTimeouts = (timeouts) => {\n  timeouts.forEach((timeout) => clearTimeout(timeout));\n  return [];\n};\nvar generateHash = () => {\n  return Math.random().toString().substring(2, 9);\n};\nvar fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver((entries, observer2) => {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        func();\n        observer2.unobserve(element);\n      }\n    });\n  }, { threshold: 1 });\n  observer.observe(element);\n};\nconst handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nconst isBodyElement = (node) => (node == null ? void 0 : node.tagName) === \"BODY\";\nconst insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : character.originalParent || originalTarget;\n  target.insertBefore(character, index_es_select(\".\" + CURSOR_CLASS, target) || null);\n};\nconst updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(Math.max(cursorPosition + steps, 0), printedCharacters.length);\n};\nvar merge = (originalObj, newObj) => {\n  return Object.assign({}, originalObj, newObj);\n};\nvar removeNode = (node) => {\n  if (!node)\n    return;\n  const nodeParent = node.parentNode;\n  const nodeToRemove = nodeParent.childNodes.length > 1 ? node : nodeParent;\n  nodeToRemove.remove();\n};\nvar repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = index_es_select(`.${CURSOR_CLASS}`, element);\n  element = (nodeToInsertBefore == null ? void 0 : nodeToInsertBefore.parentNode) || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? index_es_select(thing) : thing;\n}\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nconst wait = async (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    const cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay));\n  });\n};\nconst cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  \"margin-left\": \"-.125em\",\n  \"margin-right\": \".125em\"\n};\nconst setCursorStyles = (id, options, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce((accumulator, [item, value]) => {\n    return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n  }, \"\");\n  appendStyleBlock(`@keyframes blink-${id} { 0% {opacity: 0} 49% {opacity: 0} 50% {opacity: 1} } ${cursorSelector} { display: inline; letter-spacing: -1em; ${customProperties} animation: blink-${id} ${options.cursorSpeed / 1e3}s infinite; } ${cursorSelector}.with-delay { animation-delay: 500ms; } ${cursorSelector}.disabled { animation: none; }`, id);\n};\nfunction TypeIt(element, options = {}) {\n  const _wait = async (callback, delay, silent = false) => {\n    if (_statuses.frozen) {\n      await new Promise((resolve) => {\n        this.unfreeze = () => {\n          _statuses.frozen = false;\n          resolve();\n        };\n      });\n    }\n    silent || await _opts.beforeStep(this);\n    await wait(callback, delay, _timeouts);\n    silent || await _opts.afterStep(this);\n  };\n  const _elementIsInput = () => isInput(_element);\n  const _getPace = (index) => calculatePace(_opts)[index];\n  const _getAllChars = () => getAllChars(_element);\n  const _getActionPace = (instant, paceIndex = 0) => {\n    return instant ? _getPace(paceIndex) : 0;\n  };\n  const _maybeAppendPause = (opts = {}) => {\n    let delay = opts[\"delay\"];\n    delay && _queue.add(() => _pause(delay));\n  };\n  const _queueAndReturn = (steps, opts) => {\n    _queue.add(steps);\n    _maybeAppendPause(opts);\n    return this;\n  };\n  const _generateTemporaryOptionQueueItems = (newOptions = {}) => {\n    return [\n      () => _options(newOptions),\n      () => _options(_opts)\n    ];\n  };\n  const _addSplitPause = (items) => {\n    let delay = _opts.nextStringDelay;\n    _queue.add([\n      () => _pause(delay[0]),\n      ...items,\n      () => _pause(delay[1])\n    ]);\n  };\n  const _setUpCursor = () => {\n    if (_elementIsInput()) {\n      return;\n    }\n    let cursor = createElement(\"span\");\n    cursor.className = CURSOR_CLASS;\n    if (!_shouldRenderCursor) {\n      cursor.style.visibility = \"hidden\";\n      return cursor;\n    }\n    cursor.innerHTML = getParsedBody(_opts.cursorChar).innerHTML;\n    return cursor;\n  };\n  const _attachCursor = async () => {\n    !_elementIsInput() && _element.appendChild(_cursor);\n    _shouldRenderCursor && setCursorStyles(_id, _opts, _element);\n  };\n  const _disableCursorBlink = (shouldDisable) => {\n    if (_shouldRenderCursor) {\n      _cursor.classList.toggle(\"disabled\", shouldDisable);\n      _cursor.classList.toggle(\"with-delay\", !shouldDisable);\n    }\n  };\n  const _generateQueue = () => {\n    let strings = _opts.strings.filter((string) => !!string);\n    strings.forEach((string, index) => {\n      let chars = maybeChunkStringAsHtml(string, _opts.html);\n      _queue.add(() => _type({ chars }));\n      if (index + 1 === strings.length) {\n        return;\n      }\n      const splitPauseArgs = [\n        _opts.breakLines ? () => _type({\n          chars: [createElement(\"BR\")],\n          silent: true\n        }) : () => _delete({ num: chars.length })\n      ];\n      _addSplitPause(splitPauseArgs);\n    });\n  };\n  const _prepLoop = async (delay) => {\n    _cursorPosition && await _move({ value: _cursorPosition });\n    _queue.reset();\n    _queue.set(0, () => _pause(delay));\n    await _delete({ num: null });\n  };\n  const _maybePrependHardcodedStrings = (strings) => {\n    let existingMarkup = _element.innerHTML;\n    if (!existingMarkup) {\n      return strings;\n    }\n    _element.innerHTML = \"\";\n    if (_opts.startDelete) {\n      _element.innerHTML = existingMarkup;\n      expandTextNodes(_element);\n      _addSplitPause([\n        () => _delete({ num: null })\n      ]);\n      return strings;\n    }\n    let hardCodedStrings = existingMarkup.trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n    return hardCodedStrings.concat(strings);\n  };\n  const _fire = async () => {\n    _statuses.started = true;\n    let queueItems = _queue.getItems();\n    try {\n      for (let i = 0; i < queueItems.length; i++) {\n        await queueItems[i]();\n        _queue.markDone(i);\n        _disableCursorBlink(false);\n      }\n      _statuses.completed = true;\n      await _opts.afterComplete(this);\n      if (!_opts.loop) {\n        throw \"\";\n      }\n      let delay = _opts.loopDelay;\n      _wait(async () => {\n        await _prepLoop(delay[0]);\n        _fire();\n      }, delay[1]);\n    } catch (e) {\n    }\n    return this;\n  };\n  const _pause = (time = 0) => {\n    return _wait(() => {\n    }, time);\n  };\n  const _move = async ({\n    value,\n    to = START,\n    instant = false\n  }) => {\n    _disableCursorBlink(true);\n    let numberOfSteps = calculateCursorSteps({\n      el: _element,\n      move: value,\n      cursorPos: _cursorPosition,\n      to\n    });\n    let moveCursor = () => {\n      _cursorPosition = updateCursorPosition(numberOfSteps < 0 ? -1 : 1, _cursorPosition, _getAllChars());\n      repositionCursor(_element, _getAllChars(), _cursorPosition);\n    };\n    await _wait(async () => {\n      for (let i = 0; i < Math.abs(numberOfSteps); i++) {\n        instant ? moveCursor() : await _wait(moveCursor, _getPace(0));\n      }\n    }, _getActionPace(instant));\n  };\n  const _type = ({\n    chars,\n    silent = false,\n    instant = false\n  }) => {\n    _disableCursorBlink(true);\n    return _wait(async () => {\n      const insert = (character) => insertIntoElement(_element, character);\n      silent || await _opts.beforeString(chars, this);\n      for (let char of chars) {\n        instant || isNonVoidElement(char) ? insert(char) : await _wait(() => insert(char), _getPace(0));\n      }\n      silent || await _opts.afterString(chars, this);\n    }, _getActionPace(instant), true);\n  };\n  const _options = async (opts) => {\n    _opts = merge(_opts, opts);\n    return;\n  };\n  const _empty = async () => {\n    if (_elementIsInput()) {\n      _element.value = \"\";\n      return;\n    }\n    _getAllChars().forEach((n) => {\n      removeNode(n);\n    });\n    return;\n  };\n  const _delete = async ({\n    num = null,\n    instant = false,\n    to = START\n  }) => {\n    _disableCursorBlink(true);\n    await _wait(async () => {\n      let rounds = isNumber(num) || _elementIsInput() ? num : calculateCursorSteps({\n        el: _element,\n        move: num,\n        cursorPos: _cursorPosition,\n        to\n      });\n      const deleteIt = () => {\n        let allChars = _getAllChars();\n        if (!allChars.length)\n          return;\n        if (_elementIsInput()) {\n          _element.value = _element.value.slice(0, -1);\n        } else {\n          removeNode(allChars[_cursorPosition]);\n        }\n      };\n      for (let i = 0; i < rounds; i++) {\n        instant ? deleteIt() : await _wait(deleteIt, _getPace(1));\n      }\n    }, _getActionPace(instant, 1));\n    if (num === null && _getAllChars().length - 1 > 0) {\n      await _delete({ num: null });\n    }\n  };\n  this.break = function(actionOpts) {\n    return _queueAndReturn(() => _type({ chars: [createElement(\"BR\")], silent: true }), actionOpts);\n  };\n  this.delete = function(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    return _queueAndReturn([\n      bookEndQueueItems[0],\n      () => _delete({ num, instant, to }),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  };\n  this.empty = function(actionOpts = {}) {\n    return _queueAndReturn(_empty, actionOpts);\n  };\n  this.exec = function(func, actionOpts) {\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    return _queueAndReturn([bookEndQueueItems[0], func, bookEndQueueItems[1]], actionOpts);\n  };\n  this.move = function(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let { instant, to } = actionOpts;\n    let moveArgs = {\n      value: movementArg === null ? \"\" : movementArg,\n      to,\n      instant\n    };\n    return _queueAndReturn([\n      bookEndQueueItems[0],\n      () => _move(moveArgs),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  };\n  this.options = function(opts) {\n    opts = handleFunctionalArg(opts);\n    return _queueAndReturn(() => _options(opts), opts);\n  };\n  this.pause = function(milliseconds, actionOpts = {}) {\n    return _queueAndReturn(() => _pause(handleFunctionalArg(milliseconds)), actionOpts);\n  };\n  this.type = function(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let chars = maybeChunkStringAsHtml(string, _opts.html);\n    let { instant } = actionOpts;\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      () => _type({ chars, instant }),\n      bookEndQueueItems[1]\n    ];\n    return _queueAndReturn(itemsToQueue, actionOpts);\n  };\n  this.is = function(key) {\n    return _statuses[key];\n  };\n  this.destroy = function(shouldRemoveCursor = true) {\n    _timeouts = destroyTimeouts(_timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && removeNode(_cursor);\n    _statuses.destroyed = true;\n  };\n  this.freeze = function() {\n    _statuses.frozen = true;\n  };\n  this.unfreeze = function() {\n  };\n  this.reset = function() {\n    !this.is(\"destroyed\") && this.destroy();\n    _queue.reset();\n    _cursorPosition = 0;\n    for (let property in _statuses) {\n      _statuses[property] = false;\n    }\n    _element[_elementIsInput() ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  };\n  this.go = function() {\n    if (_statuses.started) {\n      return this;\n    }\n    _attachCursor();\n    if (!_opts.waitUntilVisible) {\n      _fire();\n      return this;\n    }\n    fireWhenVisible(_element, _fire.bind(this));\n    return this;\n  };\n  this.getQueue = () => _queue;\n  this.getOptions = () => _opts;\n  this.updateOptions = (options2) => _options(options2);\n  this.getElement = () => _element;\n  let _element = selectorToElement(element);\n  let _timeouts = [];\n  let _cursorPosition = 0;\n  let _statuses = merge({}, DEFAULT_STATUSES);\n  let _opts = merge(DEFAULT_OPTIONS, options);\n  _opts = merge(_opts, {\n    html: !_elementIsInput() && _opts.html,\n    nextStringDelay: calculateDelay(_opts.nextStringDelay),\n    loopDelay: calculateDelay(_opts.loopDelay)\n  });\n  let _id = generateHash();\n  let _queue = Queue([() => _pause(_opts.startDelay)]);\n  _element.dataset.typeitId = _id;\n  appendStyleBlock(`[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`);\n  let _shouldRenderCursor = _opts.cursor && !_elementIsInput();\n  let _cursor = _setUpCursor();\n  _opts.strings = _maybePrependHardcodedStrings(asArray(_opts.strings));\n  if (_opts.strings.length) {\n    _generateQueue();\n  }\n}\n\n\n;// CONCATENATED MODULE: ./src/js/game-start.js\n\r\n\r\nfunction lock() {\r\n  const body = document.body;\r\n  body.style.setProperty('overflow', 'hidden');\r\n}\r\n\r\nfunction unlock() {\r\n  const body = document.body;\r\n  body.style.removeProperty('overflow');\r\n}\r\n\r\nfunction hideForm() {\r\n  const gameStart = document.querySelector('.game-start');\r\n  gameStart.classList.add('fade-out');\r\n}\r\n\r\nfunction typeNames() {\r\n  const inputs = document.querySelectorAll('.game-start__input');\r\n  const names = document.querySelectorAll('.versus__name');\r\n\r\n  names.forEach((name, index) => {\r\n    new TypeIt(name, {\r\n      speed: 150,\r\n      startDelay: 800 * (index + 1),\r\n      afterComplete: function (instance) {\r\n        instance.destroy();\r\n      }\r\n    })\r\n      .type(inputs[index].value)\r\n      .go();\r\n  });\r\n}\r\n\r\nfunction formSubmit() {\r\n  const form = document.querySelector('.form');\r\n  form.addEventListener('submit', (event) => {\r\n    event.preventDefault();\r\n\r\n    const inputs = document.querySelectorAll('.game-start__input');\r\n    let errors = 0;\r\n    inputs.forEach((input) => {\r\n      const value = input.value;\r\n\r\n      if (!/[^\\s\\d]/g.test(value)) {\r\n        errors++;\r\n        input.classList.add('error');\r\n      } else {\r\n        input.classList.remove('error');\r\n      }\r\n    });\r\n\r\n    if (!errors) {\r\n      hideForm();\r\n      unlock();\r\n      typeNames();\r\n    }\r\n  });\r\n}\r\n\r\n(() => {\r\n  lock();\r\n  formSubmit();\r\n})();\r\n\n;// CONCATENATED MODULE: ./src/js/game.js\nclass Move {\r\n  constructor(state = 'red') {\r\n    this.state = state;\r\n    this.count = 0;\r\n  }\r\n\r\n  next() {\r\n    if (this.isRed()) {\r\n      this.state = 'blue';\r\n    } else if (this.isBlue()) {\r\n      this.state = 'red';\r\n    }\r\n  }\r\n\r\n  isRed() {\r\n    return this.state === 'red';\r\n  }\r\n\r\n  isBlue() {\r\n    return this.state === 'blue';\r\n  }\r\n}\r\n\r\nclass Game {\r\n  constructor(state = 'red') {\r\n    this.rows = 3;\r\n    this.cols = 3;\r\n    this.move = new Move(state);\r\n\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.build();\r\n    this.underline();\r\n    this.triggers();\r\n  }\r\n\r\n  build() {\r\n    const game = document.querySelector('.game');\r\n\r\n    for (let row = 1, index = 1; row <= this.rows; ++row) {\r\n      for (let col = 1; col <= this.cols; ++col) {\r\n        game.insertAdjacentHTML(\r\n          'beforeend',\r\n          `\r\n          <button aria-label=\"Tic Tac Toe cell\" data-row=${row} data-col=\"${col}\"\r\n            data-index=\"${index}\" class=\"game__cell btn-reset\">\r\n          </button>\r\n          `\r\n        );\r\n        index++;\r\n      }\r\n    }\r\n  }\r\n\r\n  triggers() {\r\n    const cells = document.querySelectorAll('.game__cell');\r\n    cells.forEach((cell) => {\r\n      cell.addEventListener('click', () => {\r\n        this.fill(cell);\r\n        this.move.count++;\r\n        this.checkout();\r\n        this.move.next();\r\n        this.underline();\r\n      });\r\n    });\r\n\r\n    const newGameButton = document.querySelector('.controls__new-game');\r\n    const resetButton = document.querySelector('.controls__reset');\r\n\r\n    newGameButton.addEventListener('click', () => {\r\n      this.clear();\r\n    });\r\n\r\n    resetButton.addEventListener('click', () => {\r\n      this.clear();\r\n      this.reset();\r\n    });\r\n  }\r\n\r\n  fill(cell) {\r\n    if (this.move.isRed()) {\r\n      cell.insertAdjacentHTML('beforeend', `<div class=\"cross\"></div>`);\r\n    } else {\r\n      cell.insertAdjacentHTML('beforeend', `<div class=\"circle\"></div>`);\r\n    }\r\n    cell.setAttribute('disabled', 'true');\r\n  }\r\n\r\n  checkout() {\r\n    const winDescriptor = this.checkWin(this.move.state);\r\n    if (winDescriptor) {\r\n      const { direction, cell } = winDescriptor;\r\n\r\n      const game = document.querySelector('.game');\r\n      game.setAttribute('data-direction', direction);\r\n\r\n      if (direction === 'horizontal') {\r\n        const row = cell.getAttribute('data-row');\r\n        game.style.setProperty('--value', row);\r\n      } else if (direction === 'vertical') {\r\n        const col = cell.getAttribute('data-col');\r\n        game.style.setProperty('--value', col);\r\n      }\r\n\r\n      this.disable();\r\n      this.addWin(this.move.state);\r\n\r\n      // alert(`${this.move.state} is Win!`);\r\n    } else if (this.move.count === this.rows * this.cols) {\r\n      this.addWin(this.move.state);\r\n      this.move.next();\r\n      this.addWin(this.move.state);\r\n      this.move.next();\r\n\r\n      // alert('Draw!');\r\n      this.clear();\r\n    }\r\n  }\r\n\r\n  disable() {\r\n    const cells = document.querySelectorAll('.game__cell');\r\n    cells.forEach((cell) => cell.setAttribute('disabled', 'true'));\r\n  }\r\n\r\n  checkWin(state) {\r\n    for (let i = 1; i <= this.cols; ++i) {\r\n      // vertical\r\n      for (let j = 1, ind = i; j <= this.rows; ind += this.rows, ++j) {\r\n        const cell = document.querySelector(`.game__cell[data-index=\"${ind}\"]`);\r\n        const cellState = cell.querySelector(`.${state === 'red' ? 'cross' : 'circle'}`);\r\n\r\n        if (!cellState) {\r\n          break;\r\n        }\r\n\r\n        if (cellState && j === this.rows) {\r\n          return { direction: 'vertical', cell };\r\n        }\r\n      }\r\n\r\n      // horizontal\r\n      for (let j = 1; j <= this.rows; ++j) {\r\n        const index = Math.max(0, i - 1) * this.rows + j;\r\n        const cell = document.querySelector(`.game__cell[data-index=\"${index}\"]`);\r\n        const cellState = cell.querySelector(`.${state === 'red' ? 'cross' : 'circle'}`);\r\n\r\n        if (!cellState) {\r\n          break;\r\n        }\r\n\r\n        if (cellState && j === this.rows) {\r\n          return { direction: 'horizontal', cell };\r\n        }\r\n      }\r\n    }\r\n\r\n    // main diagonal\r\n    for (let j = 0, ind = 1; j < this.rows; ind += this.rows + 1, ++j) {\r\n      const cell = document.querySelector(`.game__cell[data-index=\"${ind}\"]`);\r\n      const cellState = cell.querySelector(`.${state === 'red' ? 'cross' : 'circle'}`);\r\n\r\n      if (!cellState) {\r\n        break;\r\n      }\r\n\r\n      if (cellState && j === this.rows - 1) {\r\n        return { direction: 'main', cell };\r\n      }\r\n    }\r\n\r\n    // lateral diagonal\r\n    for (let j = 0, ind = this.cols; j < this.rows; ind += this.cols - 1, ++j) {\r\n      const cell = document.querySelector(`.game__cell[data-index=\"${ind}\"]`);\r\n      const cellState = cell.querySelector(`.${state === 'red' ? 'cross' : 'circle'}`);\r\n\r\n      if (!cellState) {\r\n        break;\r\n      }\r\n\r\n      if (cellState && j === this.rows - 1) {\r\n        return { direction: 'lateral', cell };\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  clear() {\r\n    const game = document.querySelector('.game');\r\n    game.removeAttribute('data-direction');\r\n\r\n    const cells = document.querySelectorAll('.game__cell');\r\n\r\n    cells.forEach((cell) => {\r\n      const cellState = cell.children[0];\r\n\r\n      if (cellState) {\r\n        cellState.classList.add('hide');\r\n      }\r\n\r\n      setTimeout(() => {\r\n        cell.removeAttribute('disabled');\r\n        cell.innerHTML = '';\r\n      }, 500);\r\n    });\r\n\r\n    this.move = new Move(this.move.state);\r\n  }\r\n\r\n  reset() {\r\n    const marks = document.querySelectorAll(`.versus__mark`);\r\n    marks.forEach((mark) => mark.removeAttribute('data-wins'));\r\n  }\r\n\r\n  underline() {\r\n    const names = document.querySelectorAll('.versus__name');\r\n    names.forEach((name) => name.classList.remove('active'));\r\n\r\n    const activeName = document.querySelector(`.versus__name[data-state=\"${this.move.state}\"]`);\r\n    activeName.classList.add('active');\r\n  }\r\n\r\n  addWin(state) {\r\n    const winner = document.querySelector(`.versus__name[data-state=\"${state}\"]`).previousElementSibling;\r\n    const wins = winner.getAttribute('data-wins');\r\n\r\n    if (wins) {\r\n      winner.setAttribute('data-wins', +wins + 1);\r\n    } else {\r\n      winner.setAttribute('data-wins', 1);\r\n    }\r\n  }\r\n}\r\n\r\nconst tictactoe = new Game('red');\r\n\r\n/* harmony default export */ const game = ((/* unused pure expression or super */ null && (tictactoe)));\r\n\n;// CONCATENATED MODULE: ./src/js/index.js\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BELHFFQUFxRSxJQUFJO0FBQ3pFLCtDQUErQyxxQ0FBcUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxnQkFBZ0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsTUFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUFlLHlEQUFTLElBQUM7OztBQzlPRztBQUM1QjtBQUN5QjtBQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGljLXRhYy10b2UvLi9ub2RlX21vZHVsZXMvdHlwZWl0L2Rpc3QvaW5kZXguZXMuanM/ZmUyNSIsIndlYnBhY2s6Ly90aWMtdGFjLXRvZS8uL3NyYy9qcy9nYW1lLXN0YXJ0LmpzPzE4ZmYiLCJ3ZWJwYWNrOi8vdGljLXRhYy10b2UvLi9zcmMvanMvZ2FtZS5qcz9lY2FlIiwid2VicGFjazovL3RpYy10YWMtdG9lLy4vc3JjL2pzL2luZGV4LmpzPzhhZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVHlwZUl0IGJ5IEFsZXggTWFjQXJ0aHVyIC0gaHR0cHM6Ly90eXBlaXRqcy5jb21cbnZhciBpc0FycmF5ID0gKHRoaW5nKSA9PiBBcnJheS5pc0FycmF5KHRoaW5nKTtcbnZhciBhc0FycmF5ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn07XG5jb25zdCBRdWV1ZSA9IGZ1bmN0aW9uKGluaXRpYWxJdGVtcykge1xuICBjb25zdCBhZGQgPSBmdW5jdGlvbihzdGVwcykge1xuICAgIF9xdWV1ZSA9IF9xdWV1ZS5jb25jYXQoYXNBcnJheShzdGVwcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBjb25zdCBzZXQgPSBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICAgIF9xdWV1ZVtpbmRleF0gPSBpdGVtO1xuICB9O1xuICBjb25zdCByZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIF9xdWV1ZSA9IF9xdWV1ZS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGRlbGV0ZSBpdGVtLmRvbmU7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZ2V0SXRlbXMgPSAoKSA9PiBfcXVldWUuZmlsdGVyKChpKSA9PiAhaS5kb25lKTtcbiAgY29uc3QgbWFya0RvbmUgPSAoaW5kZXgpID0+IHtcbiAgICBfcXVldWVbaW5kZXhdLmRvbmUgPSB0cnVlO1xuICB9O1xuICBsZXQgX3F1ZXVlID0gW107XG4gIGFkZChpbml0aWFsSXRlbXMpO1xuICByZXR1cm4ge1xuICAgIGFkZCxcbiAgICBzZXQsXG4gICAgcmVzZXQsXG4gICAgZ2V0SXRlbXMsXG4gICAgbWFya0RvbmVcbiAgfTtcbn07XG52YXIgdG9BcnJheSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIEFycmF5LmZyb20odmFsKTtcbn07XG52YXIgY3JlYXRlVGV4dE5vZGUgPSAoY29udGVudCkgPT4ge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCk7XG59O1xuY29uc3QgZXhwYW5kVGV4dE5vZGVzID0gKGVsZW1lbnQpID0+IHtcbiAgWy4uLmVsZW1lbnQuY2hpbGROb2Rlc10uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQubm9kZVZhbHVlKSB7XG4gICAgICBbLi4uY2hpbGQubm9kZVZhbHVlXS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNoaWxkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNyZWF0ZVRleHROb2RlKGMpLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBleHBhbmRUZXh0Tm9kZXMoY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xudmFyIGdldFBhcnNlZEJvZHkgPSAoY29udGVudCkgPT4ge1xuICBsZXQgZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gIGRvYy5ib2R5LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gIHJldHVybiBleHBhbmRUZXh0Tm9kZXMoZG9jLmJvZHkpO1xufTtcbmNvbnN0IERBVEFfQVRUUklCVVRFID0gXCJkYXRhLXR5cGVpdC1pZFwiO1xuY29uc3QgQ1VSU09SX0NMQVNTID0gXCJ0aS1jdXJzb3JcIjtcbmNvbnN0IFNUQVJUID0gXCJTVEFSVFwiO1xuY29uc3QgRU5EID0gXCJFTkRcIjtcbmNvbnN0IERFRkFVTFRfU1RBVFVTRVMgPSB7XG4gIHN0YXJ0ZWQ6IGZhbHNlLFxuICBjb21wbGV0ZWQ6IGZhbHNlLFxuICBmcm96ZW46IGZhbHNlLFxuICBkZXN0cm95ZWQ6IGZhbHNlXG59O1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICBicmVha0xpbmVzOiB0cnVlLFxuICBjdXJzb3I6IHRydWUsXG4gIGN1cnNvckNoYXI6IFwifFwiLFxuICBjdXJzb3JTcGVlZDogMWUzLFxuICBkZWxldGVTcGVlZDogbnVsbCxcbiAgaHRtbDogdHJ1ZSxcbiAgbGlmZUxpa2U6IHRydWUsXG4gIGxvb3A6IGZhbHNlLFxuICBsb29wRGVsYXk6IDc1MCxcbiAgbmV4dFN0cmluZ0RlbGF5OiA3NTAsXG4gIHNwZWVkOiAxMDAsXG4gIHN0YXJ0RGVsYXk6IDI1MCxcbiAgc3RhcnREZWxldGU6IGZhbHNlLFxuICBzdHJpbmdzOiBbXSxcbiAgd2FpdFVudGlsVmlzaWJsZTogZmFsc2UsXG4gIGJlZm9yZVN0cmluZzogKCkgPT4ge1xuICB9LFxuICBhZnRlclN0cmluZzogKCkgPT4ge1xuICB9LFxuICBiZWZvcmVTdGVwOiAoKSA9PiB7XG4gIH0sXG4gIGFmdGVyU3RlcDogKCkgPT4ge1xuICB9LFxuICBhZnRlckNvbXBsZXRlOiAoKSA9PiB7XG4gIH1cbn07XG5mdW5jdGlvbiB3YWxrRWxlbWVudE5vZGVzKGVsZW1lbnQsIHNob3VsZFJldmVyc2UgPSBmYWxzZSkge1xuICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19BTEwsIHtcbiAgICBhY2NlcHROb2RlOiAobm9kZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuICgoX2EgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLmNsYXNzTGlzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKENVUlNPUl9DTEFTUykpID8gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUIDogTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH1cbiAgfSk7XG4gIGxldCBuZXh0Tm9kZTtcbiAgbGV0IG5vZGVzID0gW107XG4gIHdoaWxlIChuZXh0Tm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgbmV4dE5vZGUub3JpZ2luYWxQYXJlbnQgPSBuZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgIG5vZGVzLnB1c2gobmV4dE5vZGUpO1xuICB9XG4gIHJldHVybiBzaG91bGRSZXZlcnNlID8gbm9kZXMucmV2ZXJzZSgpIDogbm9kZXM7XG59XG5mdW5jdGlvbiBjaHVua1N0cmluZ0FzSHRtbChzdHJpbmcpIHtcbiAgcmV0dXJuIHdhbGtFbGVtZW50Tm9kZXMoZ2V0UGFyc2VkQm9keShzdHJpbmcpKTtcbn1cbmZ1bmN0aW9uIG1heWJlQ2h1bmtTdHJpbmdBc0h0bWwoc3RyLCBhc0h0bWwgPSB0cnVlKSB7XG4gIHJldHVybiBhc0h0bWwgPyBjaHVua1N0cmluZ0FzSHRtbChzdHIpIDogdG9BcnJheShzdHIpLm1hcChjcmVhdGVUZXh0Tm9kZSk7XG59XG52YXIgY3JlYXRlRWxlbWVudCA9IChlbCkgPT4ge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbCk7XG59O1xudmFyIGFwcGVuZFN0eWxlQmxvY2sgPSAoc3R5bGVzLCBpZCA9IFwiXCIpID0+IHtcbiAgbGV0IHN0eWxlQmxvY2sgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlQmxvY2suaWQgPSBpZDtcbiAgc3R5bGVCbG9jay5hcHBlbmRDaGlsZChjcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUJsb2NrKTtcbn07XG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59O1xuY29uc3Qgc2VsZWN0ID0gKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQsIGFsbCA9IGZhbHNlKSA9PiB7XG4gIHJldHVybiBlbGVtZW50W2BxdWVyeVNlbGVjdG9yJHthbGwgPyBcIkFsbFwiIDogXCJcIn1gXShzZWxlY3Rvcik7XG59O1xudmFyIGlzSW5wdXQgPSAoZWwpID0+IHtcbiAgcmV0dXJuIFwidmFsdWVcIiBpbiBlbDtcbn07XG5jb25zdCBnZXRBbGxDaGFycyA9IChlbGVtZW50KSA9PiB7XG4gIGlmIChpc0lucHV0KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZWxlbWVudC52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHdhbGtFbGVtZW50Tm9kZXMoZWxlbWVudCwgdHJ1ZSkuZmlsdGVyKChjKSA9PiAhKGMuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSk7XG59O1xuY29uc3QgY2FsY3VsYXRlU3RlcHNUb1NlbGVjdG9yID0gKHNlbGVjdG9yLCBlbGVtZW50LCB0byA9IFNUQVJUKSA9PiB7XG4gIGxldCBpc01vdmluZ1RvTGFzdCA9IG5ldyBSZWdFeHAoRU5ELCBcImlcIikudGVzdCh0byk7XG4gIGxldCBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3RvciA/IHNlbGVjdChzZWxlY3RvciwgZWxlbWVudCkgOiBlbGVtZW50O1xuICBsZXQgc2VsZWN0ZWRFbGVtZW50Tm9kZXMgPSB3YWxrRWxlbWVudE5vZGVzKHNlbGVjdGVkRWxlbWVudCwgdHJ1ZSk7XG4gIGxldCBzZWxlY3RlZEVsZW1lbnRGaXJzdENoaWxkID0gc2VsZWN0ZWRFbGVtZW50Tm9kZXNbMF07XG4gIGxldCBzZWxlY3RlZEVsZW1lbnRMYXN0Q2hpbGQgPSBzZWxlY3RlZEVsZW1lbnROb2Rlc1tzZWxlY3RlZEVsZW1lbnROb2Rlcy5sZW5ndGggLSAxXTtcbiAgbGV0IGlzTW92aW5nVG9FbmRPZlJvb3RFbGVtZW50ID0gaXNNb3ZpbmdUb0xhc3QgJiYgIXNlbGVjdG9yO1xuICBsZXQgY2hpbGRJbmRleCA9IGlzTW92aW5nVG9FbmRPZlJvb3RFbGVtZW50ID8gMCA6IGdldEFsbENoYXJzKGVsZW1lbnQpLmZpbmRJbmRleCgoY2hhcmFjdGVyKSA9PiB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci5pc1NhbWVOb2RlKGlzTW92aW5nVG9MYXN0ID8gc2VsZWN0ZWRFbGVtZW50Rmlyc3RDaGlsZCA6IHNlbGVjdGVkRWxlbWVudExhc3RDaGlsZCk7XG4gIH0pO1xuICBpZiAoaXNNb3ZpbmdUb0xhc3QpXG4gICAgY2hpbGRJbmRleC0tO1xuICByZXR1cm4gY2hpbGRJbmRleCArIDE7XG59O1xudmFyIGNhbGN1bGF0ZUN1cnNvclN0ZXBzID0gKHtcbiAgZWwsXG4gIG1vdmUsXG4gIGN1cnNvclBvcyxcbiAgdG9cbn0pID0+IHtcbiAgaWYgKGlzTnVtYmVyKG1vdmUpKSB7XG4gICAgcmV0dXJuIG1vdmUgKiAtMTtcbiAgfVxuICBsZXQgY2hpbGRJbmRleCA9IGNhbGN1bGF0ZVN0ZXBzVG9TZWxlY3Rvcihtb3ZlLCBlbCwgdG8pO1xuICByZXR1cm4gY2hpbGRJbmRleCAtIGN1cnNvclBvcztcbn07XG52YXIgY2FsY3VsYXRlRGVsYXkgPSAoZGVsYXlBcmcpID0+IHtcbiAgaWYgKCFpc0FycmF5KGRlbGF5QXJnKSkge1xuICAgIGRlbGF5QXJnID0gW2RlbGF5QXJnIC8gMiwgZGVsYXlBcmcgLyAyXTtcbiAgfVxuICByZXR1cm4gZGVsYXlBcmc7XG59O1xudmFyIHJhbmRvbUluUmFuZ2UgPSAodmFsdWUsIHJhbmdlMikgPT4ge1xuICByZXR1cm4gTWF0aC5hYnMoTWF0aC5yYW5kb20oKSAqICh2YWx1ZSArIHJhbmdlMiAtICh2YWx1ZSAtIHJhbmdlMikpICsgKHZhbHVlIC0gcmFuZ2UyKSk7XG59O1xubGV0IHJhbmdlID0gKHZhbCkgPT4gdmFsIC8gMjtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBhY2Uob3B0aW9ucykge1xuICBsZXQgeyBzcGVlZCwgZGVsZXRlU3BlZWQsIGxpZmVMaWtlIH0gPSBvcHRpb25zO1xuICBkZWxldGVTcGVlZCA9IGRlbGV0ZVNwZWVkICE9PSBudWxsID8gZGVsZXRlU3BlZWQgOiBzcGVlZCAvIDM7XG4gIHJldHVybiBsaWZlTGlrZSA/IFtcbiAgICByYW5kb21JblJhbmdlKHNwZWVkLCByYW5nZShzcGVlZCkpLFxuICAgIHJhbmRvbUluUmFuZ2UoZGVsZXRlU3BlZWQsIHJhbmdlKGRlbGV0ZVNwZWVkKSlcbiAgXSA6IFtzcGVlZCwgZGVsZXRlU3BlZWRdO1xufVxudmFyIGRlc3Ryb3lUaW1lb3V0cyA9ICh0aW1lb3V0cykgPT4ge1xuICB0aW1lb3V0cy5mb3JFYWNoKCh0aW1lb3V0KSA9PiBjbGVhclRpbWVvdXQodGltZW91dCkpO1xuICByZXR1cm4gW107XG59O1xudmFyIGdlbmVyYXRlSGFzaCA9ICgpID0+IHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiwgOSk7XG59O1xudmFyIGZpcmVXaGVuVmlzaWJsZSA9IChlbGVtZW50LCBmdW5jKSA9PiB7XG4gIGxldCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcywgb2JzZXJ2ZXIyKSA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgICAgb2JzZXJ2ZXIyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgeyB0aHJlc2hvbGQ6IDEgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG59O1xuY29uc3QgaGFuZGxlRnVuY3Rpb25hbEFyZyA9IChhcmcpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIiA/IGFyZygpIDogYXJnO1xufTtcbmNvbnN0IGlzQm9keUVsZW1lbnQgPSAobm9kZSkgPT4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudGFnTmFtZSkgPT09IFwiQk9EWVwiO1xuY29uc3QgaW5zZXJ0SW50b0VsZW1lbnQgPSAob3JpZ2luYWxUYXJnZXQsIGNoYXJhY3RlcikgPT4ge1xuICBpZiAoaXNJbnB1dChvcmlnaW5hbFRhcmdldCkpIHtcbiAgICBvcmlnaW5hbFRhcmdldC52YWx1ZSA9IGAke29yaWdpbmFsVGFyZ2V0LnZhbHVlfSR7Y2hhcmFjdGVyLnRleHRDb250ZW50fWA7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNoYXJhY3Rlci5pbm5lckhUTUwgPSBcIlwiO1xuICBsZXQgdGFyZ2V0ID0gaXNCb2R5RWxlbWVudChjaGFyYWN0ZXIub3JpZ2luYWxQYXJlbnQpID8gb3JpZ2luYWxUYXJnZXQgOiBjaGFyYWN0ZXIub3JpZ2luYWxQYXJlbnQgfHwgb3JpZ2luYWxUYXJnZXQ7XG4gIHRhcmdldC5pbnNlcnRCZWZvcmUoY2hhcmFjdGVyLCBzZWxlY3QoXCIuXCIgKyBDVVJTT1JfQ0xBU1MsIHRhcmdldCkgfHwgbnVsbCk7XG59O1xuY29uc3QgdXBkYXRlQ3Vyc29yUG9zaXRpb24gPSAoc3RlcHMsIGN1cnNvclBvc2l0aW9uLCBwcmludGVkQ2hhcmFjdGVycykgPT4ge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoY3Vyc29yUG9zaXRpb24gKyBzdGVwcywgMCksIHByaW50ZWRDaGFyYWN0ZXJzLmxlbmd0aCk7XG59O1xudmFyIG1lcmdlID0gKG9yaWdpbmFsT2JqLCBuZXdPYmopID0+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsT2JqLCBuZXdPYmopO1xufTtcbnZhciByZW1vdmVOb2RlID0gKG5vZGUpID0+IHtcbiAgaWYgKCFub2RlKVxuICAgIHJldHVybjtcbiAgY29uc3Qgbm9kZVBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgY29uc3Qgbm9kZVRvUmVtb3ZlID0gbm9kZVBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgPyBub2RlIDogbm9kZVBhcmVudDtcbiAgbm9kZVRvUmVtb3ZlLnJlbW92ZSgpO1xufTtcbnZhciByZXBvc2l0aW9uQ3Vyc29yID0gKGVsZW1lbnQsIGFsbENoYXJzLCBuZXdDdXJzb3JQb3NpdGlvbikgPT4ge1xuICBsZXQgbm9kZVRvSW5zZXJ0QmVmb3JlID0gYWxsQ2hhcnNbbmV3Q3Vyc29yUG9zaXRpb24gLSAxXTtcbiAgbGV0IGN1cnNvciA9IHNlbGVjdChgLiR7Q1VSU09SX0NMQVNTfWAsIGVsZW1lbnQpO1xuICBlbGVtZW50ID0gKG5vZGVUb0luc2VydEJlZm9yZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZVRvSW5zZXJ0QmVmb3JlLnBhcmVudE5vZGUpIHx8IGVsZW1lbnQ7XG4gIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGN1cnNvciwgbm9kZVRvSW5zZXJ0QmVmb3JlIHx8IG51bGwpO1xufTtcbmZ1bmN0aW9uIHNlbGVjdG9yVG9FbGVtZW50KHRoaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IFwic3RyaW5nXCIgPyBzZWxlY3QodGhpbmcpIDogdGhpbmc7XG59XG5jb25zdCBpc05vblZvaWRFbGVtZW50ID0gKGVsKSA9PiAvPCguKyk+KC4qPyk8XFwvKC4rKT4vLnRlc3QoZWwub3V0ZXJIVE1MKTtcbmNvbnN0IHdhaXQgPSBhc3luYyAoY2FsbGJhY2ssIGRlbGF5LCB0aW1lb3V0cykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBjYiA9IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGNhbGxiYWNrKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICB0aW1lb3V0cy5wdXNoKHNldFRpbWVvdXQoY2IsIGRlbGF5KSk7XG4gIH0pO1xufTtcbmNvbnN0IGN1cnNvckZvbnRTdHlsZXMgPSB7XG4gIFwiZm9udC1mYW1pbHlcIjogXCJcIixcbiAgXCJmb250LXdlaWdodFwiOiBcIlwiLFxuICBcImZvbnQtc2l6ZVwiOiBcIlwiLFxuICBcImZvbnQtc3R5bGVcIjogXCJcIixcbiAgXCJsaW5lLWhlaWdodFwiOiBcIlwiLFxuICBjb2xvcjogXCJcIixcbiAgXCJtYXJnaW4tbGVmdFwiOiBcIi0uMTI1ZW1cIixcbiAgXCJtYXJnaW4tcmlnaHRcIjogXCIuMTI1ZW1cIlxufTtcbmNvbnN0IHNldEN1cnNvclN0eWxlcyA9IChpZCwgb3B0aW9ucywgZWxlbWVudCkgPT4ge1xuICBsZXQgcm9vdFNlbGVjdG9yID0gYFske0RBVEFfQVRUUklCVVRFfT0nJHtpZH0nXWA7XG4gIGxldCBjdXJzb3JTZWxlY3RvciA9IGAke3Jvb3RTZWxlY3Rvcn0gLiR7Q1VSU09SX0NMQVNTfWA7XG4gIGxldCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGxldCBjdXN0b21Qcm9wZXJ0aWVzID0gT2JqZWN0LmVudHJpZXMoY3Vyc29yRm9udFN0eWxlcykucmVkdWNlKChhY2N1bXVsYXRvciwgW2l0ZW0sIHZhbHVlXSkgPT4ge1xuICAgIHJldHVybiBgJHthY2N1bXVsYXRvcn0gJHtpdGVtfTogdmFyKC0tdGktY3Vyc29yLSR7aXRlbX0sICR7dmFsdWUgfHwgY29tcHV0ZWRTdHlsZXNbaXRlbV19KTtgO1xuICB9LCBcIlwiKTtcbiAgYXBwZW5kU3R5bGVCbG9jayhgQGtleWZyYW1lcyBibGluay0ke2lkfSB7IDAlIHtvcGFjaXR5OiAwfSA0OSUge29wYWNpdHk6IDB9IDUwJSB7b3BhY2l0eTogMX0gfSAke2N1cnNvclNlbGVjdG9yfSB7IGRpc3BsYXk6IGlubGluZTsgbGV0dGVyLXNwYWNpbmc6IC0xZW07ICR7Y3VzdG9tUHJvcGVydGllc30gYW5pbWF0aW9uOiBibGluay0ke2lkfSAke29wdGlvbnMuY3Vyc29yU3BlZWQgLyAxZTN9cyBpbmZpbml0ZTsgfSAke2N1cnNvclNlbGVjdG9yfS53aXRoLWRlbGF5IHsgYW5pbWF0aW9uLWRlbGF5OiA1MDBtczsgfSAke2N1cnNvclNlbGVjdG9yfS5kaXNhYmxlZCB7IGFuaW1hdGlvbjogbm9uZTsgfWAsIGlkKTtcbn07XG5mdW5jdGlvbiBUeXBlSXQoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IF93YWl0ID0gYXN5bmMgKGNhbGxiYWNrLCBkZWxheSwgc2lsZW50ID0gZmFsc2UpID0+IHtcbiAgICBpZiAoX3N0YXR1c2VzLmZyb3plbikge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy51bmZyZWV6ZSA9ICgpID0+IHtcbiAgICAgICAgICBfc3RhdHVzZXMuZnJvemVuID0gZmFsc2U7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNpbGVudCB8fCBhd2FpdCBfb3B0cy5iZWZvcmVTdGVwKHRoaXMpO1xuICAgIGF3YWl0IHdhaXQoY2FsbGJhY2ssIGRlbGF5LCBfdGltZW91dHMpO1xuICAgIHNpbGVudCB8fCBhd2FpdCBfb3B0cy5hZnRlclN0ZXAodGhpcyk7XG4gIH07XG4gIGNvbnN0IF9lbGVtZW50SXNJbnB1dCA9ICgpID0+IGlzSW5wdXQoX2VsZW1lbnQpO1xuICBjb25zdCBfZ2V0UGFjZSA9IChpbmRleCkgPT4gY2FsY3VsYXRlUGFjZShfb3B0cylbaW5kZXhdO1xuICBjb25zdCBfZ2V0QWxsQ2hhcnMgPSAoKSA9PiBnZXRBbGxDaGFycyhfZWxlbWVudCk7XG4gIGNvbnN0IF9nZXRBY3Rpb25QYWNlID0gKGluc3RhbnQsIHBhY2VJbmRleCA9IDApID0+IHtcbiAgICByZXR1cm4gaW5zdGFudCA/IF9nZXRQYWNlKHBhY2VJbmRleCkgOiAwO1xuICB9O1xuICBjb25zdCBfbWF5YmVBcHBlbmRQYXVzZSA9IChvcHRzID0ge30pID0+IHtcbiAgICBsZXQgZGVsYXkgPSBvcHRzW1wiZGVsYXlcIl07XG4gICAgZGVsYXkgJiYgX3F1ZXVlLmFkZCgoKSA9PiBfcGF1c2UoZGVsYXkpKTtcbiAgfTtcbiAgY29uc3QgX3F1ZXVlQW5kUmV0dXJuID0gKHN0ZXBzLCBvcHRzKSA9PiB7XG4gICAgX3F1ZXVlLmFkZChzdGVwcyk7XG4gICAgX21heWJlQXBwZW5kUGF1c2Uob3B0cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGNvbnN0IF9nZW5lcmF0ZVRlbXBvcmFyeU9wdGlvblF1ZXVlSXRlbXMgPSAobmV3T3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgICgpID0+IF9vcHRpb25zKG5ld09wdGlvbnMpLFxuICAgICAgKCkgPT4gX29wdGlvbnMoX29wdHMpXG4gICAgXTtcbiAgfTtcbiAgY29uc3QgX2FkZFNwbGl0UGF1c2UgPSAoaXRlbXMpID0+IHtcbiAgICBsZXQgZGVsYXkgPSBfb3B0cy5uZXh0U3RyaW5nRGVsYXk7XG4gICAgX3F1ZXVlLmFkZChbXG4gICAgICAoKSA9PiBfcGF1c2UoZGVsYXlbMF0pLFxuICAgICAgLi4uaXRlbXMsXG4gICAgICAoKSA9PiBfcGF1c2UoZGVsYXlbMV0pXG4gICAgXSk7XG4gIH07XG4gIGNvbnN0IF9zZXRVcEN1cnNvciA9ICgpID0+IHtcbiAgICBpZiAoX2VsZW1lbnRJc0lucHV0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnNvciA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGN1cnNvci5jbGFzc05hbWUgPSBDVVJTT1JfQ0xBU1M7XG4gICAgaWYgKCFfc2hvdWxkUmVuZGVyQ3Vyc29yKSB7XG4gICAgICBjdXJzb3Iuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICBjdXJzb3IuaW5uZXJIVE1MID0gZ2V0UGFyc2VkQm9keShfb3B0cy5jdXJzb3JDaGFyKS5pbm5lckhUTUw7XG4gICAgcmV0dXJuIGN1cnNvcjtcbiAgfTtcbiAgY29uc3QgX2F0dGFjaEN1cnNvciA9IGFzeW5jICgpID0+IHtcbiAgICAhX2VsZW1lbnRJc0lucHV0KCkgJiYgX2VsZW1lbnQuYXBwZW5kQ2hpbGQoX2N1cnNvcik7XG4gICAgX3Nob3VsZFJlbmRlckN1cnNvciAmJiBzZXRDdXJzb3JTdHlsZXMoX2lkLCBfb3B0cywgX2VsZW1lbnQpO1xuICB9O1xuICBjb25zdCBfZGlzYWJsZUN1cnNvckJsaW5rID0gKHNob3VsZERpc2FibGUpID0+IHtcbiAgICBpZiAoX3Nob3VsZFJlbmRlckN1cnNvcikge1xuICAgICAgX2N1cnNvci5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgc2hvdWxkRGlzYWJsZSk7XG4gICAgICBfY3Vyc29yLmNsYXNzTGlzdC50b2dnbGUoXCJ3aXRoLWRlbGF5XCIsICFzaG91bGREaXNhYmxlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IF9nZW5lcmF0ZVF1ZXVlID0gKCkgPT4ge1xuICAgIGxldCBzdHJpbmdzID0gX29wdHMuc3RyaW5ncy5maWx0ZXIoKHN0cmluZykgPT4gISFzdHJpbmcpO1xuICAgIHN0cmluZ3MuZm9yRWFjaCgoc3RyaW5nLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IGNoYXJzID0gbWF5YmVDaHVua1N0cmluZ0FzSHRtbChzdHJpbmcsIF9vcHRzLmh0bWwpO1xuICAgICAgX3F1ZXVlLmFkZCgoKSA9PiBfdHlwZSh7IGNoYXJzIH0pKTtcbiAgICAgIGlmIChpbmRleCArIDEgPT09IHN0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwbGl0UGF1c2VBcmdzID0gW1xuICAgICAgICBfb3B0cy5icmVha0xpbmVzID8gKCkgPT4gX3R5cGUoe1xuICAgICAgICAgIGNoYXJzOiBbY3JlYXRlRWxlbWVudChcIkJSXCIpXSxcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSkgOiAoKSA9PiBfZGVsZXRlKHsgbnVtOiBjaGFycy5sZW5ndGggfSlcbiAgICAgIF07XG4gICAgICBfYWRkU3BsaXRQYXVzZShzcGxpdFBhdXNlQXJncyk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IF9wcmVwTG9vcCA9IGFzeW5jIChkZWxheSkgPT4ge1xuICAgIF9jdXJzb3JQb3NpdGlvbiAmJiBhd2FpdCBfbW92ZSh7IHZhbHVlOiBfY3Vyc29yUG9zaXRpb24gfSk7XG4gICAgX3F1ZXVlLnJlc2V0KCk7XG4gICAgX3F1ZXVlLnNldCgwLCAoKSA9PiBfcGF1c2UoZGVsYXkpKTtcbiAgICBhd2FpdCBfZGVsZXRlKHsgbnVtOiBudWxsIH0pO1xuICB9O1xuICBjb25zdCBfbWF5YmVQcmVwZW5kSGFyZGNvZGVkU3RyaW5ncyA9IChzdHJpbmdzKSA9PiB7XG4gICAgbGV0IGV4aXN0aW5nTWFya3VwID0gX2VsZW1lbnQuaW5uZXJIVE1MO1xuICAgIGlmICghZXhpc3RpbmdNYXJrdXApIHtcbiAgICAgIHJldHVybiBzdHJpbmdzO1xuICAgIH1cbiAgICBfZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGlmIChfb3B0cy5zdGFydERlbGV0ZSkge1xuICAgICAgX2VsZW1lbnQuaW5uZXJIVE1MID0gZXhpc3RpbmdNYXJrdXA7XG4gICAgICBleHBhbmRUZXh0Tm9kZXMoX2VsZW1lbnQpO1xuICAgICAgX2FkZFNwbGl0UGF1c2UoW1xuICAgICAgICAoKSA9PiBfZGVsZXRlKHsgbnVtOiBudWxsIH0pXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBzdHJpbmdzO1xuICAgIH1cbiAgICBsZXQgaGFyZENvZGVkU3RyaW5ncyA9IGV4aXN0aW5nTWFya3VwLnRyaW0oKS5zcGxpdCgvPGJyKD86XFxzKj8pKD86XFwvKT8+Lyk7XG4gICAgcmV0dXJuIGhhcmRDb2RlZFN0cmluZ3MuY29uY2F0KHN0cmluZ3MpO1xuICB9O1xuICBjb25zdCBfZmlyZSA9IGFzeW5jICgpID0+IHtcbiAgICBfc3RhdHVzZXMuc3RhcnRlZCA9IHRydWU7XG4gICAgbGV0IHF1ZXVlSXRlbXMgPSBfcXVldWUuZ2V0SXRlbXMoKTtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHF1ZXVlSXRlbXNbaV0oKTtcbiAgICAgICAgX3F1ZXVlLm1hcmtEb25lKGkpO1xuICAgICAgICBfZGlzYWJsZUN1cnNvckJsaW5rKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIF9zdGF0dXNlcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgYXdhaXQgX29wdHMuYWZ0ZXJDb21wbGV0ZSh0aGlzKTtcbiAgICAgIGlmICghX29wdHMubG9vcCkge1xuICAgICAgICB0aHJvdyBcIlwiO1xuICAgICAgfVxuICAgICAgbGV0IGRlbGF5ID0gX29wdHMubG9vcERlbGF5O1xuICAgICAgX3dhaXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBfcHJlcExvb3AoZGVsYXlbMF0pO1xuICAgICAgICBfZmlyZSgpO1xuICAgICAgfSwgZGVsYXlbMV0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGNvbnN0IF9wYXVzZSA9ICh0aW1lID0gMCkgPT4ge1xuICAgIHJldHVybiBfd2FpdCgoKSA9PiB7XG4gICAgfSwgdGltZSk7XG4gIH07XG4gIGNvbnN0IF9tb3ZlID0gYXN5bmMgKHtcbiAgICB2YWx1ZSxcbiAgICB0byA9IFNUQVJULFxuICAgIGluc3RhbnQgPSBmYWxzZVxuICB9KSA9PiB7XG4gICAgX2Rpc2FibGVDdXJzb3JCbGluayh0cnVlKTtcbiAgICBsZXQgbnVtYmVyT2ZTdGVwcyA9IGNhbGN1bGF0ZUN1cnNvclN0ZXBzKHtcbiAgICAgIGVsOiBfZWxlbWVudCxcbiAgICAgIG1vdmU6IHZhbHVlLFxuICAgICAgY3Vyc29yUG9zOiBfY3Vyc29yUG9zaXRpb24sXG4gICAgICB0b1xuICAgIH0pO1xuICAgIGxldCBtb3ZlQ3Vyc29yID0gKCkgPT4ge1xuICAgICAgX2N1cnNvclBvc2l0aW9uID0gdXBkYXRlQ3Vyc29yUG9zaXRpb24obnVtYmVyT2ZTdGVwcyA8IDAgPyAtMSA6IDEsIF9jdXJzb3JQb3NpdGlvbiwgX2dldEFsbENoYXJzKCkpO1xuICAgICAgcmVwb3NpdGlvbkN1cnNvcihfZWxlbWVudCwgX2dldEFsbENoYXJzKCksIF9jdXJzb3JQb3NpdGlvbik7XG4gICAgfTtcbiAgICBhd2FpdCBfd2FpdChhc3luYyAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGguYWJzKG51bWJlck9mU3RlcHMpOyBpKyspIHtcbiAgICAgICAgaW5zdGFudCA/IG1vdmVDdXJzb3IoKSA6IGF3YWl0IF93YWl0KG1vdmVDdXJzb3IsIF9nZXRQYWNlKDApKTtcbiAgICAgIH1cbiAgICB9LCBfZ2V0QWN0aW9uUGFjZShpbnN0YW50KSk7XG4gIH07XG4gIGNvbnN0IF90eXBlID0gKHtcbiAgICBjaGFycyxcbiAgICBzaWxlbnQgPSBmYWxzZSxcbiAgICBpbnN0YW50ID0gZmFsc2VcbiAgfSkgPT4ge1xuICAgIF9kaXNhYmxlQ3Vyc29yQmxpbmsodHJ1ZSk7XG4gICAgcmV0dXJuIF93YWl0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluc2VydCA9IChjaGFyYWN0ZXIpID0+IGluc2VydEludG9FbGVtZW50KF9lbGVtZW50LCBjaGFyYWN0ZXIpO1xuICAgICAgc2lsZW50IHx8IGF3YWl0IF9vcHRzLmJlZm9yZVN0cmluZyhjaGFycywgdGhpcyk7XG4gICAgICBmb3IgKGxldCBjaGFyIG9mIGNoYXJzKSB7XG4gICAgICAgIGluc3RhbnQgfHwgaXNOb25Wb2lkRWxlbWVudChjaGFyKSA/IGluc2VydChjaGFyKSA6IGF3YWl0IF93YWl0KCgpID0+IGluc2VydChjaGFyKSwgX2dldFBhY2UoMCkpO1xuICAgICAgfVxuICAgICAgc2lsZW50IHx8IGF3YWl0IF9vcHRzLmFmdGVyU3RyaW5nKGNoYXJzLCB0aGlzKTtcbiAgICB9LCBfZ2V0QWN0aW9uUGFjZShpbnN0YW50KSwgdHJ1ZSk7XG4gIH07XG4gIGNvbnN0IF9vcHRpb25zID0gYXN5bmMgKG9wdHMpID0+IHtcbiAgICBfb3B0cyA9IG1lcmdlKF9vcHRzLCBvcHRzKTtcbiAgICByZXR1cm47XG4gIH07XG4gIGNvbnN0IF9lbXB0eSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoX2VsZW1lbnRJc0lucHV0KCkpIHtcbiAgICAgIF9lbGVtZW50LnZhbHVlID0gXCJcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2dldEFsbENoYXJzKCkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgcmVtb3ZlTm9kZShuKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH07XG4gIGNvbnN0IF9kZWxldGUgPSBhc3luYyAoe1xuICAgIG51bSA9IG51bGwsXG4gICAgaW5zdGFudCA9IGZhbHNlLFxuICAgIHRvID0gU1RBUlRcbiAgfSkgPT4ge1xuICAgIF9kaXNhYmxlQ3Vyc29yQmxpbmsodHJ1ZSk7XG4gICAgYXdhaXQgX3dhaXQoYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJvdW5kcyA9IGlzTnVtYmVyKG51bSkgfHwgX2VsZW1lbnRJc0lucHV0KCkgPyBudW0gOiBjYWxjdWxhdGVDdXJzb3JTdGVwcyh7XG4gICAgICAgIGVsOiBfZWxlbWVudCxcbiAgICAgICAgbW92ZTogbnVtLFxuICAgICAgICBjdXJzb3JQb3M6IF9jdXJzb3JQb3NpdGlvbixcbiAgICAgICAgdG9cbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGVsZXRlSXQgPSAoKSA9PiB7XG4gICAgICAgIGxldCBhbGxDaGFycyA9IF9nZXRBbGxDaGFycygpO1xuICAgICAgICBpZiAoIWFsbENoYXJzLmxlbmd0aClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChfZWxlbWVudElzSW5wdXQoKSkge1xuICAgICAgICAgIF9lbGVtZW50LnZhbHVlID0gX2VsZW1lbnQudmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZU5vZGUoYWxsQ2hhcnNbX2N1cnNvclBvc2l0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgIGluc3RhbnQgPyBkZWxldGVJdCgpIDogYXdhaXQgX3dhaXQoZGVsZXRlSXQsIF9nZXRQYWNlKDEpKTtcbiAgICAgIH1cbiAgICB9LCBfZ2V0QWN0aW9uUGFjZShpbnN0YW50LCAxKSk7XG4gICAgaWYgKG51bSA9PT0gbnVsbCAmJiBfZ2V0QWxsQ2hhcnMoKS5sZW5ndGggLSAxID4gMCkge1xuICAgICAgYXdhaXQgX2RlbGV0ZSh7IG51bTogbnVsbCB9KTtcbiAgICB9XG4gIH07XG4gIHRoaXMuYnJlYWsgPSBmdW5jdGlvbihhY3Rpb25PcHRzKSB7XG4gICAgcmV0dXJuIF9xdWV1ZUFuZFJldHVybigoKSA9PiBfdHlwZSh7IGNoYXJzOiBbY3JlYXRlRWxlbWVudChcIkJSXCIpXSwgc2lsZW50OiB0cnVlIH0pLCBhY3Rpb25PcHRzKTtcbiAgfTtcbiAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbihudW1DaGFyYWN0ZXJzID0gbnVsbCwgYWN0aW9uT3B0cyA9IHt9KSB7XG4gICAgbnVtQ2hhcmFjdGVycyA9IGhhbmRsZUZ1bmN0aW9uYWxBcmcobnVtQ2hhcmFjdGVycyk7XG4gICAgbGV0IGJvb2tFbmRRdWV1ZUl0ZW1zID0gX2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcyhhY3Rpb25PcHRzKTtcbiAgICBsZXQgbnVtID0gbnVtQ2hhcmFjdGVycztcbiAgICBsZXQgeyBpbnN0YW50LCB0byB9ID0gYWN0aW9uT3B0cztcbiAgICByZXR1cm4gX3F1ZXVlQW5kUmV0dXJuKFtcbiAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzBdLFxuICAgICAgKCkgPT4gX2RlbGV0ZSh7IG51bSwgaW5zdGFudCwgdG8gfSksXG4gICAgICBib29rRW5kUXVldWVJdGVtc1sxXVxuICAgIF0sIGFjdGlvbk9wdHMpO1xuICB9O1xuICB0aGlzLmVtcHR5ID0gZnVuY3Rpb24oYWN0aW9uT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIF9xdWV1ZUFuZFJldHVybihfZW1wdHksIGFjdGlvbk9wdHMpO1xuICB9O1xuICB0aGlzLmV4ZWMgPSBmdW5jdGlvbihmdW5jLCBhY3Rpb25PcHRzKSB7XG4gICAgbGV0IGJvb2tFbmRRdWV1ZUl0ZW1zID0gX2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcyhhY3Rpb25PcHRzKTtcbiAgICByZXR1cm4gX3F1ZXVlQW5kUmV0dXJuKFtib29rRW5kUXVldWVJdGVtc1swXSwgZnVuYywgYm9va0VuZFF1ZXVlSXRlbXNbMV1dLCBhY3Rpb25PcHRzKTtcbiAgfTtcbiAgdGhpcy5tb3ZlID0gZnVuY3Rpb24obW92ZW1lbnRBcmcsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIG1vdmVtZW50QXJnID0gaGFuZGxlRnVuY3Rpb25hbEFyZyhtb3ZlbWVudEFyZyk7XG4gICAgbGV0IGJvb2tFbmRRdWV1ZUl0ZW1zID0gX2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcyhhY3Rpb25PcHRzKTtcbiAgICBsZXQgeyBpbnN0YW50LCB0byB9ID0gYWN0aW9uT3B0cztcbiAgICBsZXQgbW92ZUFyZ3MgPSB7XG4gICAgICB2YWx1ZTogbW92ZW1lbnRBcmcgPT09IG51bGwgPyBcIlwiIDogbW92ZW1lbnRBcmcsXG4gICAgICB0byxcbiAgICAgIGluc3RhbnRcbiAgICB9O1xuICAgIHJldHVybiBfcXVldWVBbmRSZXR1cm4oW1xuICAgICAgYm9va0VuZFF1ZXVlSXRlbXNbMF0sXG4gICAgICAoKSA9PiBfbW92ZShtb3ZlQXJncyksXG4gICAgICBib29rRW5kUXVldWVJdGVtc1sxXVxuICAgIF0sIGFjdGlvbk9wdHMpO1xuICB9O1xuICB0aGlzLm9wdGlvbnMgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IGhhbmRsZUZ1bmN0aW9uYWxBcmcob3B0cyk7XG4gICAgcmV0dXJuIF9xdWV1ZUFuZFJldHVybigoKSA9PiBfb3B0aW9ucyhvcHRzKSwgb3B0cyk7XG4gIH07XG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbihtaWxsaXNlY29uZHMsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIHJldHVybiBfcXVldWVBbmRSZXR1cm4oKCkgPT4gX3BhdXNlKGhhbmRsZUZ1bmN0aW9uYWxBcmcobWlsbGlzZWNvbmRzKSksIGFjdGlvbk9wdHMpO1xuICB9O1xuICB0aGlzLnR5cGUgPSBmdW5jdGlvbihzdHJpbmcsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIHN0cmluZyA9IGhhbmRsZUZ1bmN0aW9uYWxBcmcoc3RyaW5nKTtcbiAgICBsZXQgYm9va0VuZFF1ZXVlSXRlbXMgPSBfZ2VuZXJhdGVUZW1wb3JhcnlPcHRpb25RdWV1ZUl0ZW1zKGFjdGlvbk9wdHMpO1xuICAgIGxldCBjaGFycyA9IG1heWJlQ2h1bmtTdHJpbmdBc0h0bWwoc3RyaW5nLCBfb3B0cy5odG1sKTtcbiAgICBsZXQgeyBpbnN0YW50IH0gPSBhY3Rpb25PcHRzO1xuICAgIGxldCBpdGVtc1RvUXVldWUgPSBbXG4gICAgICBib29rRW5kUXVldWVJdGVtc1swXSxcbiAgICAgICgpID0+IF90eXBlKHsgY2hhcnMsIGluc3RhbnQgfSksXG4gICAgICBib29rRW5kUXVldWVJdGVtc1sxXVxuICAgIF07XG4gICAgcmV0dXJuIF9xdWV1ZUFuZFJldHVybihpdGVtc1RvUXVldWUsIGFjdGlvbk9wdHMpO1xuICB9O1xuICB0aGlzLmlzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIF9zdGF0dXNlc1trZXldO1xuICB9O1xuICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbihzaG91bGRSZW1vdmVDdXJzb3IgPSB0cnVlKSB7XG4gICAgX3RpbWVvdXRzID0gZGVzdHJveVRpbWVvdXRzKF90aW1lb3V0cyk7XG4gICAgaGFuZGxlRnVuY3Rpb25hbEFyZyhzaG91bGRSZW1vdmVDdXJzb3IpICYmIHJlbW92ZU5vZGUoX2N1cnNvcik7XG4gICAgX3N0YXR1c2VzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH07XG4gIHRoaXMuZnJlZXplID0gZnVuY3Rpb24oKSB7XG4gICAgX3N0YXR1c2VzLmZyb3plbiA9IHRydWU7XG4gIH07XG4gIHRoaXMudW5mcmVlemUgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICF0aGlzLmlzKFwiZGVzdHJveWVkXCIpICYmIHRoaXMuZGVzdHJveSgpO1xuICAgIF9xdWV1ZS5yZXNldCgpO1xuICAgIF9jdXJzb3JQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gX3N0YXR1c2VzKSB7XG4gICAgICBfc3RhdHVzZXNbcHJvcGVydHldID0gZmFsc2U7XG4gICAgfVxuICAgIF9lbGVtZW50W19lbGVtZW50SXNJbnB1dCgpID8gXCJ2YWx1ZVwiIDogXCJpbm5lckhUTUxcIl0gPSBcIlwiO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICB0aGlzLmdvID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKF9zdGF0dXNlcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2F0dGFjaEN1cnNvcigpO1xuICAgIGlmICghX29wdHMud2FpdFVudGlsVmlzaWJsZSkge1xuICAgICAgX2ZpcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaXJlV2hlblZpc2libGUoX2VsZW1lbnQsIF9maXJlLmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICB0aGlzLmdldFF1ZXVlID0gKCkgPT4gX3F1ZXVlO1xuICB0aGlzLmdldE9wdGlvbnMgPSAoKSA9PiBfb3B0cztcbiAgdGhpcy51cGRhdGVPcHRpb25zID0gKG9wdGlvbnMyKSA9PiBfb3B0aW9ucyhvcHRpb25zMik7XG4gIHRoaXMuZ2V0RWxlbWVudCA9ICgpID0+IF9lbGVtZW50O1xuICBsZXQgX2VsZW1lbnQgPSBzZWxlY3RvclRvRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IF90aW1lb3V0cyA9IFtdO1xuICBsZXQgX2N1cnNvclBvc2l0aW9uID0gMDtcbiAgbGV0IF9zdGF0dXNlcyA9IG1lcmdlKHt9LCBERUZBVUxUX1NUQVRVU0VTKTtcbiAgbGV0IF9vcHRzID0gbWVyZ2UoREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgX29wdHMgPSBtZXJnZShfb3B0cywge1xuICAgIGh0bWw6ICFfZWxlbWVudElzSW5wdXQoKSAmJiBfb3B0cy5odG1sLFxuICAgIG5leHRTdHJpbmdEZWxheTogY2FsY3VsYXRlRGVsYXkoX29wdHMubmV4dFN0cmluZ0RlbGF5KSxcbiAgICBsb29wRGVsYXk6IGNhbGN1bGF0ZURlbGF5KF9vcHRzLmxvb3BEZWxheSlcbiAgfSk7XG4gIGxldCBfaWQgPSBnZW5lcmF0ZUhhc2goKTtcbiAgbGV0IF9xdWV1ZSA9IFF1ZXVlKFsoKSA9PiBfcGF1c2UoX29wdHMuc3RhcnREZWxheSldKTtcbiAgX2VsZW1lbnQuZGF0YXNldC50eXBlaXRJZCA9IF9pZDtcbiAgYXBwZW5kU3R5bGVCbG9jayhgWyR7REFUQV9BVFRSSUJVVEV9XTpiZWZvcmUge2NvbnRlbnQ6ICcuJzsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMDsgdmlzaWJpbGl0eTogaGlkZGVuO31gKTtcbiAgbGV0IF9zaG91bGRSZW5kZXJDdXJzb3IgPSBfb3B0cy5jdXJzb3IgJiYgIV9lbGVtZW50SXNJbnB1dCgpO1xuICBsZXQgX2N1cnNvciA9IF9zZXRVcEN1cnNvcigpO1xuICBfb3B0cy5zdHJpbmdzID0gX21heWJlUHJlcGVuZEhhcmRjb2RlZFN0cmluZ3MoYXNBcnJheShfb3B0cy5zdHJpbmdzKSk7XG4gIGlmIChfb3B0cy5zdHJpbmdzLmxlbmd0aCkge1xuICAgIF9nZW5lcmF0ZVF1ZXVlKCk7XG4gIH1cbn1cbmV4cG9ydCB7IFR5cGVJdCBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgVHlwZUl0IGZyb20gJ3R5cGVpdCc7XHJcblxyXG5mdW5jdGlvbiBsb2NrKCkge1xyXG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xyXG4gIGJvZHkuc3R5bGUuc2V0UHJvcGVydHkoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bmxvY2soKSB7XHJcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XHJcbiAgYm9keS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3ZlcmZsb3cnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlkZUZvcm0oKSB7XHJcbiAgY29uc3QgZ2FtZVN0YXJ0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmdhbWUtc3RhcnQnKTtcclxuICBnYW1lU3RhcnQuY2xhc3NMaXN0LmFkZCgnZmFkZS1vdXQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHlwZU5hbWVzKCkge1xyXG4gIGNvbnN0IGlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5nYW1lLXN0YXJ0X19pbnB1dCcpO1xyXG4gIGNvbnN0IG5hbWVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnZlcnN1c19fbmFtZScpO1xyXG5cclxuICBuYW1lcy5mb3JFYWNoKChuYW1lLCBpbmRleCkgPT4ge1xyXG4gICAgbmV3IFR5cGVJdChuYW1lLCB7XHJcbiAgICAgIHNwZWVkOiAxNTAsXHJcbiAgICAgIHN0YXJ0RGVsYXk6IDgwMCAqIChpbmRleCArIDEpLFxyXG4gICAgICBhZnRlckNvbXBsZXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICAgIC50eXBlKGlucHV0c1tpbmRleF0udmFsdWUpXHJcbiAgICAgIC5nbygpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtU3VibWl0KCkge1xyXG4gIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybScpO1xyXG4gIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgKGV2ZW50KSA9PiB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIGNvbnN0IGlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5nYW1lLXN0YXJ0X19pbnB1dCcpO1xyXG4gICAgbGV0IGVycm9ycyA9IDA7XHJcbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcclxuICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZTtcclxuXHJcbiAgICAgIGlmICghL1teXFxzXFxkXS9nLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgZXJyb3JzKys7XHJcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdlcnJvcicpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIWVycm9ycykge1xyXG4gICAgICBoaWRlRm9ybSgpO1xyXG4gICAgICB1bmxvY2soKTtcclxuICAgICAgdHlwZU5hbWVzKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbigoKSA9PiB7XHJcbiAgbG9jaygpO1xyXG4gIGZvcm1TdWJtaXQoKTtcclxufSkoKTtcclxuIiwiY2xhc3MgTW92ZSB7XHJcbiAgY29uc3RydWN0b3Ioc3RhdGUgPSAncmVkJykge1xyXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgfVxyXG5cclxuICBuZXh0KCkge1xyXG4gICAgaWYgKHRoaXMuaXNSZWQoKSkge1xyXG4gICAgICB0aGlzLnN0YXRlID0gJ2JsdWUnO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQmx1ZSgpKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUgPSAncmVkJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlzUmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09ICdyZWQnO1xyXG4gIH1cclxuXHJcbiAgaXNCbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09ICdibHVlJztcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEdhbWUge1xyXG4gIGNvbnN0cnVjdG9yKHN0YXRlID0gJ3JlZCcpIHtcclxuICAgIHRoaXMucm93cyA9IDM7XHJcbiAgICB0aGlzLmNvbHMgPSAzO1xyXG4gICAgdGhpcy5tb3ZlID0gbmV3IE1vdmUoc3RhdGUpO1xyXG5cclxuICAgIHRoaXMuaW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgaW5pdCgpIHtcclxuICAgIHRoaXMuYnVpbGQoKTtcclxuICAgIHRoaXMudW5kZXJsaW5lKCk7XHJcbiAgICB0aGlzLnRyaWdnZXJzKCk7XHJcbiAgfVxyXG5cclxuICBidWlsZCgpIHtcclxuICAgIGNvbnN0IGdhbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZ2FtZScpO1xyXG5cclxuICAgIGZvciAobGV0IHJvdyA9IDEsIGluZGV4ID0gMTsgcm93IDw9IHRoaXMucm93czsgKytyb3cpIHtcclxuICAgICAgZm9yIChsZXQgY29sID0gMTsgY29sIDw9IHRoaXMuY29sczsgKytjb2wpIHtcclxuICAgICAgICBnYW1lLmluc2VydEFkamFjZW50SFRNTChcclxuICAgICAgICAgICdiZWZvcmVlbmQnLFxyXG4gICAgICAgICAgYFxyXG4gICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPVwiVGljIFRhYyBUb2UgY2VsbFwiIGRhdGEtcm93PSR7cm93fSBkYXRhLWNvbD1cIiR7Y29sfVwiXHJcbiAgICAgICAgICAgIGRhdGEtaW5kZXg9XCIke2luZGV4fVwiIGNsYXNzPVwiZ2FtZV9fY2VsbCBidG4tcmVzZXRcIj5cclxuICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaW5kZXgrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdHJpZ2dlcnMoKSB7XHJcbiAgICBjb25zdCBjZWxscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5nYW1lX19jZWxsJyk7XHJcbiAgICBjZWxscy5mb3JFYWNoKChjZWxsKSA9PiB7XHJcbiAgICAgIGNlbGwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5maWxsKGNlbGwpO1xyXG4gICAgICAgIHRoaXMubW92ZS5jb3VudCsrO1xyXG4gICAgICAgIHRoaXMuY2hlY2tvdXQoKTtcclxuICAgICAgICB0aGlzLm1vdmUubmV4dCgpO1xyXG4gICAgICAgIHRoaXMudW5kZXJsaW5lKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbmV3R2FtZUJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sc19fbmV3LWdhbWUnKTtcclxuICAgIGNvbnN0IHJlc2V0QnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2xzX19yZXNldCcpO1xyXG5cclxuICAgIG5ld0dhbWVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJlc2V0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZmlsbChjZWxsKSB7XHJcbiAgICBpZiAodGhpcy5tb3ZlLmlzUmVkKCkpIHtcclxuICAgICAgY2VsbC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGA8ZGl2IGNsYXNzPVwiY3Jvc3NcIj48L2Rpdj5gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNlbGwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBgPGRpdiBjbGFzcz1cImNpcmNsZVwiPjwvZGl2PmApO1xyXG4gICAgfVxyXG4gICAgY2VsbC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcclxuICB9XHJcblxyXG4gIGNoZWNrb3V0KCkge1xyXG4gICAgY29uc3Qgd2luRGVzY3JpcHRvciA9IHRoaXMuY2hlY2tXaW4odGhpcy5tb3ZlLnN0YXRlKTtcclxuICAgIGlmICh3aW5EZXNjcmlwdG9yKSB7XHJcbiAgICAgIGNvbnN0IHsgZGlyZWN0aW9uLCBjZWxsIH0gPSB3aW5EZXNjcmlwdG9yO1xyXG5cclxuICAgICAgY29uc3QgZ2FtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5nYW1lJyk7XHJcbiAgICAgIGdhbWUuc2V0QXR0cmlidXRlKCdkYXRhLWRpcmVjdGlvbicsIGRpcmVjdGlvbik7XHJcblxyXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICBjb25zdCByb3cgPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1yb3cnKTtcclxuICAgICAgICBnYW1lLnN0eWxlLnNldFByb3BlcnR5KCctLXZhbHVlJywgcm93KTtcclxuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICBjb25zdCBjb2wgPSBjZWxsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2wnKTtcclxuICAgICAgICBnYW1lLnN0eWxlLnNldFByb3BlcnR5KCctLXZhbHVlJywgY29sKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kaXNhYmxlKCk7XHJcbiAgICAgIHRoaXMuYWRkV2luKHRoaXMubW92ZS5zdGF0ZSk7XHJcblxyXG4gICAgICAvLyBhbGVydChgJHt0aGlzLm1vdmUuc3RhdGV9IGlzIFdpbiFgKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5tb3ZlLmNvdW50ID09PSB0aGlzLnJvd3MgKiB0aGlzLmNvbHMpIHtcclxuICAgICAgdGhpcy5hZGRXaW4odGhpcy5tb3ZlLnN0YXRlKTtcclxuICAgICAgdGhpcy5tb3ZlLm5leHQoKTtcclxuICAgICAgdGhpcy5hZGRXaW4odGhpcy5tb3ZlLnN0YXRlKTtcclxuICAgICAgdGhpcy5tb3ZlLm5leHQoKTtcclxuXHJcbiAgICAgIC8vIGFsZXJ0KCdEcmF3IScpO1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaXNhYmxlKCkge1xyXG4gICAgY29uc3QgY2VsbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZ2FtZV9fY2VsbCcpO1xyXG4gICAgY2VsbHMuZm9yRWFjaCgoY2VsbCkgPT4gY2VsbC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKSk7XHJcbiAgfVxyXG5cclxuICBjaGVja1dpbihzdGF0ZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5jb2xzOyArK2kpIHtcclxuICAgICAgLy8gdmVydGljYWxcclxuICAgICAgZm9yIChsZXQgaiA9IDEsIGluZCA9IGk7IGogPD0gdGhpcy5yb3dzOyBpbmQgKz0gdGhpcy5yb3dzLCArK2opIHtcclxuICAgICAgICBjb25zdCBjZWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLmdhbWVfX2NlbGxbZGF0YS1pbmRleD1cIiR7aW5kfVwiXWApO1xyXG4gICAgICAgIGNvbnN0IGNlbGxTdGF0ZSA9IGNlbGwucXVlcnlTZWxlY3RvcihgLiR7c3RhdGUgPT09ICdyZWQnID8gJ2Nyb3NzJyA6ICdjaXJjbGUnfWApO1xyXG5cclxuICAgICAgICBpZiAoIWNlbGxTdGF0ZSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2VsbFN0YXRlICYmIGogPT09IHRoaXMucm93cykge1xyXG4gICAgICAgICAgcmV0dXJuIHsgZGlyZWN0aW9uOiAndmVydGljYWwnLCBjZWxsIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBob3Jpem9udGFsXHJcbiAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IHRoaXMucm93czsgKytqKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLm1heCgwLCBpIC0gMSkgKiB0aGlzLnJvd3MgKyBqO1xyXG4gICAgICAgIGNvbnN0IGNlbGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuZ2FtZV9fY2VsbFtkYXRhLWluZGV4PVwiJHtpbmRleH1cIl1gKTtcclxuICAgICAgICBjb25zdCBjZWxsU3RhdGUgPSBjZWxsLnF1ZXJ5U2VsZWN0b3IoYC4ke3N0YXRlID09PSAncmVkJyA/ICdjcm9zcycgOiAnY2lyY2xlJ31gKTtcclxuXHJcbiAgICAgICAgaWYgKCFjZWxsU3RhdGUpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNlbGxTdGF0ZSAmJiBqID09PSB0aGlzLnJvd3MpIHtcclxuICAgICAgICAgIHJldHVybiB7IGRpcmVjdGlvbjogJ2hvcml6b250YWwnLCBjZWxsIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFpbiBkaWFnb25hbFxyXG4gICAgZm9yIChsZXQgaiA9IDAsIGluZCA9IDE7IGogPCB0aGlzLnJvd3M7IGluZCArPSB0aGlzLnJvd3MgKyAxLCArK2opIHtcclxuICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC5nYW1lX19jZWxsW2RhdGEtaW5kZXg9XCIke2luZH1cIl1gKTtcclxuICAgICAgY29uc3QgY2VsbFN0YXRlID0gY2VsbC5xdWVyeVNlbGVjdG9yKGAuJHtzdGF0ZSA9PT0gJ3JlZCcgPyAnY3Jvc3MnIDogJ2NpcmNsZSd9YCk7XHJcblxyXG4gICAgICBpZiAoIWNlbGxTdGF0ZSkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2VsbFN0YXRlICYmIGogPT09IHRoaXMucm93cyAtIDEpIHtcclxuICAgICAgICByZXR1cm4geyBkaXJlY3Rpb246ICdtYWluJywgY2VsbCB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbGF0ZXJhbCBkaWFnb25hbFxyXG4gICAgZm9yIChsZXQgaiA9IDAsIGluZCA9IHRoaXMuY29sczsgaiA8IHRoaXMucm93czsgaW5kICs9IHRoaXMuY29scyAtIDEsICsraikge1xyXG4gICAgICBjb25zdCBjZWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLmdhbWVfX2NlbGxbZGF0YS1pbmRleD1cIiR7aW5kfVwiXWApO1xyXG4gICAgICBjb25zdCBjZWxsU3RhdGUgPSBjZWxsLnF1ZXJ5U2VsZWN0b3IoYC4ke3N0YXRlID09PSAncmVkJyA/ICdjcm9zcycgOiAnY2lyY2xlJ31gKTtcclxuXHJcbiAgICAgIGlmICghY2VsbFN0YXRlKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjZWxsU3RhdGUgJiYgaiA9PT0gdGhpcy5yb3dzIC0gMSkge1xyXG4gICAgICAgIHJldHVybiB7IGRpcmVjdGlvbjogJ2xhdGVyYWwnLCBjZWxsIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjbGVhcigpIHtcclxuICAgIGNvbnN0IGdhbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZ2FtZScpO1xyXG4gICAgZ2FtZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZGlyZWN0aW9uJyk7XHJcblxyXG4gICAgY29uc3QgY2VsbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZ2FtZV9fY2VsbCcpO1xyXG5cclxuICAgIGNlbGxzLmZvckVhY2goKGNlbGwpID0+IHtcclxuICAgICAgY29uc3QgY2VsbFN0YXRlID0gY2VsbC5jaGlsZHJlblswXTtcclxuXHJcbiAgICAgIGlmIChjZWxsU3RhdGUpIHtcclxuICAgICAgICBjZWxsU3RhdGUuY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBjZWxsLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcclxuICAgICAgICBjZWxsLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICB9LCA1MDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5tb3ZlID0gbmV3IE1vdmUodGhpcy5tb3ZlLnN0YXRlKTtcclxuICB9XHJcblxyXG4gIHJlc2V0KCkge1xyXG4gICAgY29uc3QgbWFya3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAudmVyc3VzX19tYXJrYCk7XHJcbiAgICBtYXJrcy5mb3JFYWNoKChtYXJrKSA9PiBtYXJrLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS13aW5zJykpO1xyXG4gIH1cclxuXHJcbiAgdW5kZXJsaW5lKCkge1xyXG4gICAgY29uc3QgbmFtZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudmVyc3VzX19uYW1lJyk7XHJcbiAgICBuYW1lcy5mb3JFYWNoKChuYW1lKSA9PiBuYW1lLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpKTtcclxuXHJcbiAgICBjb25zdCBhY3RpdmVOYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLnZlcnN1c19fbmFtZVtkYXRhLXN0YXRlPVwiJHt0aGlzLm1vdmUuc3RhdGV9XCJdYCk7XHJcbiAgICBhY3RpdmVOYW1lLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG4gIH1cclxuXHJcbiAgYWRkV2luKHN0YXRlKSB7XHJcbiAgICBjb25zdCB3aW5uZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAudmVyc3VzX19uYW1lW2RhdGEtc3RhdGU9XCIke3N0YXRlfVwiXWApLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XHJcbiAgICBjb25zdCB3aW5zID0gd2lubmVyLmdldEF0dHJpYnV0ZSgnZGF0YS13aW5zJyk7XHJcblxyXG4gICAgaWYgKHdpbnMpIHtcclxuICAgICAgd2lubmVyLnNldEF0dHJpYnV0ZSgnZGF0YS13aW5zJywgK3dpbnMgKyAxKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdpbm5lci5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2lucycsIDEpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgdGljdGFjdG9lID0gbmV3IEdhbWUoJ3JlZCcpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgdGljdGFjdG9lO1xyXG4iLCJpbXBvcnQgJy4uL3Njc3Mvc3R5bGUuc2Nzcyc7XHJcblxyXG5pbXBvcnQgJy4vZ2FtZS1zdGFydC5qcyc7XHJcbmltcG9ydCAnLi9nYW1lLmpzJztcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///577\n")}},__webpack_exports__={};__webpack_modules__[577]()})();